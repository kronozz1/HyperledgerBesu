"use strict";
/**
 * Class that enables interaction with the Orchestrate API
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrchestrateClient = void 0;
const HttpClient_1 = require("./HttpClient");
const TRANSACTIONS_ENDPOINT = '/transactions';
const CONTRACTS_ENDPOINT = '/contracts';
class OrchestrateClient {
    /**
     * Creates a new OrchestrateClient instance
     *
     * @param host - URL and port of the Orchestrate API
     */
    constructor(host) {
        this.client = new HttpClient_1.HttpClient({ host });
    }
    /**
     * Fetch a transaction by UUID
     *
     * @param txUUID transaction UUID
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    getTransaction(txUUID, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = {
                path: `${TRANSACTIONS_ENDPOINT}/${txUUID}`
            };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Search for transactions
     *
     * @param searchRequest transaction search request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    searchTransactions(searchRequest, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = {
                path: TRANSACTIONS_ENDPOINT,
                query: searchRequest
            };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Deploy contract request
     *
     * @param deployRequest deploy contract request data
     * @param idempotencyKey Optional transaction unique identifier
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    deployContract(deployRequest, idempotencyKey, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._postWithIdempotencyKey(`${TRANSACTIONS_ENDPOINT}/deploy-contract`, deployRequest, authToken, idempotencyKey, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Send contract transaction request
     *
     * @param sendRequest transaction request data
     * @param idempotencyKey Optional transaction unique identifier
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    sendTransaction(sendRequest, idempotencyKey, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._postWithIdempotencyKey(`${TRANSACTIONS_ENDPOINT}/send`, sendRequest, authToken, idempotencyKey, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Send raw transaction request
     *
     * @param sendRawRequest raw transaction request data
     * @param idempotencyKey Optional transaction unique identifier
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    sendRawTransaction(sendRawRequest, idempotencyKey, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._postWithIdempotencyKey(`${TRANSACTIONS_ENDPOINT}/send-raw`, sendRawRequest, authToken, idempotencyKey, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Send transfer transaction request
     *
     * @param transferRequest transfer transaction request data
     * @param idempotencyKey Optional transaction unique identifier
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    transfer(transferRequest, idempotencyKey, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._postWithIdempotencyKey(`${TRANSACTIONS_ENDPOINT}/transfer`, transferRequest, authToken, idempotencyKey, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Fetch list of registered chains
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    searchChains(authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = { path: '/chains' };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Register a new chain
     * @param chainRequest register chain request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    registerChain(chainRequest, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post('/chains', chainRequest, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Update a registered chain
     * @param chainUUID uuid of registered chain
     * @param chainRequest register chain request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    updateChain(chainUUID, chainRequest, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.patch(`/chains/${chainUUID}`, chainRequest, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Delete a registered chain
     * @param chainUUID uuid of registered chain
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    deleteChain(chainUUID, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.delete(`/chains/${chainUUID}`, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Fetch list of registered faucets
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    searchFaucets(authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = { path: '/faucets' };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Register a faucet account
     * @param faucetRequest register faucet request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    registerFaucet(faucetRequest, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post('/faucets', faucetRequest, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Fetch a list of registered contract names
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    getContractsCatalog(authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = { path: CONTRACTS_ENDPOINT };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Gets all the tags of a contract by name
     *
     * @param name - Contract name
     * @param authToken - authorization token
     * @param headers HTTP request headers.
     * @returns the tags of the contract
     */
    getContractTags(name, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = {
                path: `${CONTRACTS_ENDPOINT}/${name}`
            };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Fetch a contract by name and tag
     *
     * @param name - Contract name
     * @param tag - Contract tag
     * @param authToken - authorization token
     * @param headers HTTP request headers.
     * @returns the contract details
     */
    getContract(name, tag, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = { path: `${CONTRACTS_ENDPOINT}/${name}/${tag || 'latest'}` };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Register a new contract
     * @param contractRequest register contract request payload
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    registerContract(contractRequest, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post(CONTRACTS_ENDPOINT, contractRequest, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Search for accounts
     *
     * @param searchRequest accounts search filters
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    searchAccounts(searchRequest, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = {
                path: '/accounts',
                query: searchRequest
            };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Fetch an account by address
     *
     * @param address account's Ethereum address
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    getAccount(address, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = {
                path: `/accounts/${address}`
            };
            try {
                const res = yield this.client.get(req, authToken, headers);
                return res.data;
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Creates a new account
     *
     * @param request account creation request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    createAccount(request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post('/accounts', request || {}, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Imports an account
     *
     * @param request account import request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    importAccount(request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post('/accounts/import', request, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Signs a message using a registered Ethereum account
     *
     * @param address account's Ethereum address
     * @param request sign message request
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    signMessage(address, request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post(`/accounts/${address}/sign-message`, request, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Updates an account's information
     *
     * @param address account's Ethereum address
     * @param request update request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    updateAccount(address, request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.patch(`/accounts/${address}`, request, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Signs a typed data message using a registered Ethereum account
     *
     * @param address account's Ethereum address
     * @param request sign typed data request
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    signTypedData(address, request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.post(`/accounts/${address}/sign-typed-data`, request, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Verifies the signature of a message
     *
     * @param request update request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    verifyMessage(request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.client.post(`/accounts/verify-message`, request, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Verifies the signature of a typed data message
     *
     * @param request update request data
     * @param authToken Bearer token. Required when multi-tenancy is enabled
     * @param headers HTTP request headers.
     */
    verifyTypedDataSignature(request, authToken, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.client.post(`/accounts/verify-typed-data-signature`, request, authToken, headers);
            }
            catch (e) {
                throw e;
            }
        });
    }
    _postWithIdempotencyKey(path, data, authToken, idempotencyKey, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const newHeaders = Object.assign({}, headers);
            if (idempotencyKey) {
                newHeaders['X-Idempotency-Key'] = idempotencyKey;
            }
            return yield this.client.post(path, data, authToken, newHeaders);
        });
    }
}
exports.OrchestrateClient = OrchestrateClient;
