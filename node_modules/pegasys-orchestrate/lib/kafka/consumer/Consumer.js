"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consumer = void 0;
const constants_1 = require("../constants");
const KafkaClient_1 = require("../KafkaClient");
const helpers_1 = require("./helpers");
/**
 * Consumes and decodes Orchestrate messages
 */
class Consumer extends KafkaClient_1.KafkaClient {
    /**
     * Creates a new instance of the Consumer
     *
     * @param brokers - List of brokers to connect to
     * @param topics - List of topics to consume
     * @param kafkaConfig - Kafka client configuration
     * @param consumerConfig - Consumer configuration
     */
    constructor(brokers, topics = [constants_1.DEFAULT_TOPIC_TX_DECODED, constants_1.DEFAULT_TOPIC_TX_RECOVER], kafkaConfig, consumerConfig) {
        super(Object.assign(Object.assign({ clientId: 'orchestrate-sdk-consumer' }, kafkaConfig), { brokers }));
        this.topics = topics;
        this.consumer = this.kafka.consumer(Object.assign({ groupId: 'orchestrate-sdk-consumer' }, consumerConfig));
    }
    /**
     * Returns the list of topics
     */
    getTopics() {
        return this.topics;
    }
    /**
     * Connects to Kafka and subscribes to each topic
     *
     * @returns a Promise that resolves if the connection is successful and rejects otherwise
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.consumer.connect();
            for (const topic of this.topics) {
                yield this.consumer.subscribe({ topic });
            }
            this.isReady = true;
        });
    }
    /**
     * Disconnects from the broker and unsubscribes from the topics
     *
     * @returns a Promise that resolves if the connection is disconnected successfully
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkReadiness();
            yield this.consumer.disconnect();
            this.removeAllListeners();
            this.isReady = false;
        });
    }
    /**
     * Starts consuming messages
     */
    consume() {
        return __awaiter(this, void 0, void 0, function* () {
            // Not absolutely necessary but enforces user to call connect() before calling consume()
            this.checkReadiness();
            yield this.consumer.run({
                autoCommit: false,
                eachMessage: (payload) => __awaiter(this, void 0, void 0, function* () {
                    helpers_1.onMessageReceived(payload, this);
                })
            });
        });
    }
    /**
     * Commits the offsets specified by the message
     *
     * @param message - Message from which to get the offset
     */
    commit(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkReadiness();
            yield this.consumer.commitOffsets([
                {
                    offset: (parseInt(message.offset, 10) + 1).toString(),
                    topic: message.topic,
                    partition: message.partition
                }
            ]);
        });
    }
    checkReadiness() {
        if (!this.isReady) {
            throw new Error('Consumer is not currently connected, did you forget to call connect()?');
        }
    }
}
exports.Consumer = Consumer;
